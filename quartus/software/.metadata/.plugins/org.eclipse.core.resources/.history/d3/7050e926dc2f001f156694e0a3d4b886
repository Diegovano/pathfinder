/*
 * "Hello World" example.
 *
 * This example prints 'Hello from Nios II' to the STDOUT stream. It runs on
 * the Nios II 'standard', 'full_featured', 'fast', and 'low_cost' example
 * designs. It runs with or without the MicroC/OS-II RTOS and requires a STDOUT
 * device in your system's hardware.
 * The memory footprint of this hosted application is ~69 kbytes by default
 * using the standard reference design.
 *
 * For a reduced footprint version of this template, and an explanation of how
 * to reduce the memory footprint for a given application, see the
 * "small_hello_world" template.
 *
 */

#include <alt_types.h>
#include <stdio.h>
#include <sys/alt_timestamp.h> // for timing
#include <system.h>
#include <math.h>
#include "includes_and_settings.h"



void write_dijkstra_cache(float edge_value, int from_node, int to_node){
	long dataa = (to_node<<16) + from_node;
	float datab = edge_value;
	long result = ALT_CI_DIJKSTRA32_FLOAT_0(0,dataa,datab);
}

float read_dijkstra_cache(int from_node, int to_node){
	long dataa = (to_node<<16) + from_node;
	return ALT_CI_DIJKSTRA32_FLOAT_0(1,dataa,0);
}

int read_path_vector(int node){
	long dataa = node;
	return ALT_CI_DIJKSTRA32_FLOAT_0(3,dataa,0);
}

float run_dijkstra (int from_node, int to_node, int number_of_nodes){
	ALT_CI_DIJKSTRA32_FLOAT_0(2,0,0); //a manual software reset cuz hardware reset buggy
	long dataa = (to_node <<16) + from_node;
	long datab = number_of_nodes;
	return ALT_CI_DIJKSTRA32_FLOAT_0(2,dataa,datab);
}

int main()
{
  unsigned int ctrl = DMA_IRQ_E_BIT | DMA_LEEN | DMA_WORD;
  DMA dma(DMA_0_BASE, ctrl);
  dma.irq_reg(DMA_0_IRQ_INTERRUPT_CONTROLLER_ID, DMA_0_IRQ);

  printf("Hello from Nios II!\n");
  for (int row=0; row < 16; row++){
	  for (int column=0; column < 16; column++){
		  if (row == column){
			  write_dijkstra_cache(0,row, column);
		  }
		  else{
			  write_dijkstra_cache(0x7F800000,row, column);
		  }
	  }
  }

  int* float_ptr = (int*)alt_uncached_malloc(8);
  write_dijkstra_cache(33.532, 13, 6);
  printf("Custom instruction read 1: %f \n", read_dijkstra_cache(13,6));


  *float_ptr = 5;
  unsigned int node_from = 13;
  unsigned int node_to = 6;
  unsigned int address = DIJKSTRA32_FLOAT_0_BASE + (node_to << 8) + (node_from << 0);
  dma.copy((void*)float_ptr, (void*)(DIJKSTRA32_FLOAT_0_BASE+address), 4);




  printf("Custom instruction read after DMA: %x \n", read_dijkstra_cache(13,6));

  dma.copy((void*)(address), (void*)float_ptr, 4);
  printf("DMA read: %x\n", *float_ptr);

//
//  write_dijkstra_cache(53.887, 13, 12);
//
//  write_dijkstra_cache(62.337, 1, 11);
//  write_dijkstra_cache(33.73, 1, 12);
//
//  write_dijkstra_cache(19.803, 2, 12);
//  write_dijkstra_cache(28.225, 2, 1);
//
//  write_dijkstra_cache(10.796, 3, 8);
//  write_dijkstra_cache(154.774, 3, 5);
//  write_dijkstra_cache(122.668, 3, 4);
//
//  write_dijkstra_cache(122.668, 4, 3);
//
//  write_dijkstra_cache(154.774, 5, 3);
//
//  write_dijkstra_cache(33.532, 6, 13);
//  write_dijkstra_cache(181.396, 6, 10);
//  write_dijkstra_cache(183.129, 6, 9);
//
//  write_dijkstra_cache(143.458, 7, 8);
//
//  write_dijkstra_cache(41.055, 8, 10);
//  write_dijkstra_cache(10.796, 8, 3);
//  write_dijkstra_cache(143.458, 8, 7);
//
//  write_dijkstra_cache(183.129, 9, 6);
//
//  write_dijkstra_cache(41.055, 10, 8);
//  write_dijkstra_cache(181.396, 10, 6);
//
//  write_dijkstra_cache(62.337, 11, 1);
//
//  write_dijkstra_cache(53.887, 12, 13);
//  write_dijkstra_cache(19.803, 12, 2);



//
//  for (int row = 0; row <14; row++){
//  	  for (int column=0; column <14; column++){
//  		  printf("%f \t", read_dijkstra_cache(row,column));
//  	  }
//  	  printf("\n");
//  }
//
//    alt_64 proc_ticks = 0;
//    alt_u64 time1 = 0;
//    alt_u64 time3 = 0;
//
//    int iterations = 1000;
//    int size = 30;
//    // The code that you want to time goes here
//    alt_timestamp_start();
//
//    for (int i=0; i<iterations; i++){
//  	  time1 = alt_timestamp();
//  	  run_dijkstra(1,5,14);
//  	  time3 = alt_timestamp();
//  	  proc_ticks += (time3 - time1);
//    }
//    int k = alt_timestamp_freq() * 1e-6 * iterations; // ticks per ms
//    double proc_us = (double)proc_ticks / (double)k;
//
//    printf("Profiling Results: %i iteration(s), \nproc_ticks: %lld,\tproc_us: %f\tavg: %f\n",
//  		  iterations, proc_ticks, proc_us, proc_us);
//
//
//  printf("shortest distance: %f \n", run_dijkstra(1,5,14));
//
// for (int i=0; i <14; i++){
//	 printf("%d: %d \n",i,read_path_vector(i));
// }

  printf("done");
//
//
//
//  float testvector[8][8] = {
//		  {0,205,201,248,188,181,125,301},
//		  {205,0,160,132,176,123,215,189},
//		  {201,160,0,130,140,87,88,122},
//		  {248,132,130,0,259,67,237,175},
//		  {188,176,140,259,0,226,170,193},
//		  {181,123,87,67,226,0,79,225},
//		  {125,215,88,237,170,79,0,177},
//		  {301,189,122,175,193,225,177,0}};
//  for (int row=0; row <8; row++){
//	  for (int column=0; column <8; column++){
//		  write_dijkstra_cache(testvector[row][column],row,column);
//	  }
//  }
//  for (int row = 0; row <8; row++){
//  	  for (int column=0; column <8; column++){
//  		 printf("%f \t", read_dijkstra_cache(row,column));
//  	  }
//  	  printf("\n");
//  }
  alt_uncached_free(float_ptr);
  return 0;
}
